<!-- RPG v 0.2.1 -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>RPG v 0.2.1</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #000;
      color: #fff;
      font-family: Consolas, "Lucida Console", monospace;
      height: 100%; width: 100%;
      overflow: hidden;
    }
    #mainContainer {
      display: flex;
      flex-direction: row;
      width: 100%; height: 100vh;
      box-sizing: border-box;
    }
    #leftPanel {
      flex: 1 1 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
    }
    #gameCanvas {
      background: #000;
      width: 100%;
      height: 100%;
    }
    #rightPanel {
      flex: 1 1 auto;
      padding: 1rem;
      background: #222;
      display: flex;
      flex-direction: column;
      overflow: auto;
    }
    #playerStats { margin-bottom: .5rem; font-size: 16px; color: #0f0; }
    #messages { margin-bottom: .5rem; font-size: 14px; color: #ff9; }
    #dialogues { margin-bottom: .5rem; font-size: 14px; color: #9cf; }
    #commandsHelp { font-size: 14px; color: #ccc; margin-top: auto; }
    #commandsHelp ul { list-style: none; margin: 0; padding: 0; }
    #commandsHelp li { margin-bottom: .3rem; }
    #commandsHelp strong { color: #fff; }
    #shareControls { margin-top: 1rem; }
    #shareControls button { padding: 0.4rem 0.8rem; font-size: 14px; cursor: pointer; }
    #shareModal { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; }
    #shareModal.open { display: flex; }
    #shareModal .modalContent { background: #111; border: 1px solid #555; padding: 1rem; width: 320px; box-shadow: 0 0 12px rgba(0,0,0,0.5); }
    #shareModal .modalContent h3 { margin-top: 0; }
    #shareModal .modalContent input { width: 100%; padding: 0.4rem; margin: 0.5rem 0; border: 1px solid #444; background: #000; color: #fff; }
    #shareModal .modalActions { display: flex; gap: 0.5rem; justify-content: flex-end; }
    #shareModal .modalActions button { padding: 0.4rem 0.8rem; }
  </style>
</head>
<body>
<div id="mainContainer">
  <div id="leftPanel">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
  </div>
  <div id="rightPanel">
    <div id="playerStats"></div>
    <div id="messages"></div>
    <div id="dialogues"></div>
    <div id="shareControls">
      <button id="openShareModal">Share game</button>
    </div>
    <div id="commandsHelp">
      <strong>Commands (Ultima + KC):</strong>
      <ul>
        <li><strong>Arrow Keys</strong>: Move (~333 ms cooldown)</li>
        <li><strong>T</strong>: Take item on your tile</li>
        <li><strong>E</strong>: Talk to adjacent NPC (branching dialogues)</li>
        <li><strong>I</strong>: Show inventory</li>
        <li><strong>F</strong>: Block wizard’s fireball</li>
        <li><strong>S</strong>: "Szał Bitewny" (Rage) for +20 SF (5s)</li>
      </ul>
    </div>
  </div>
</div>

<div id="shareModal" aria-modal="true" role="dialog">
  <div class="modalContent">
    <h3>Share this adventure</h3>
    <p>Copy the link below to share the current game.</p>
    <input id="shareLink" type="text" readonly value="" />
    <div class="modalActions">
      <button id="copyShareLink">Copy link</button>
      <button id="closeShareModal">Close</button>
    </div>
  </div>
</div>

<script src="share-modal.js"></script>
<script>
// ----- CONFIGURATION -----
const MAP_WIDTH = 128, MAP_HEIGHT = 48;
const CAMERA_WIDTH = 56, CAMERA_HEIGHT = 22;
const TILE_W = 48, TILE_H = 24, TILE_Z = 12;

const gameData = {
  tileDefs: {
    GRASS: { color: "#2f2", passable: true },
    FOREST: { color: "#0a0", passable: true },
    MOUNTAIN: { color: "#ddd", passable: false },
    HILL: { color: "#bbb", passable: true },
    WATER: { color: "#06a", passable: true },
    ROAD: { color: "#aaa", passable: true },
    WALL: { color: "#ccc", passable: false },
    CASTLE: { color: "#ccc", passable: false },
    CITY: { color: "#fa4", passable: true },
    VILLAGE: { color: "#e7c07d", passable: true },
    TOWER: { color: "#ccbbee", passable: false },
    FARM: { color: "#d8bf8e", passable: true },
    BUILDING: { color: "#b8c0d4", passable: false }
  },
  specialTiles: {
    NPC: { color: "#0cf" },
    ITEM: { color: "#fa0" },
    FIREBALL: { color: "#f44" },
    PLAYER: "#ff7a00"
  },
  items: [
    { x: 10, y: 3, name: "Sword", taken: false },
    { x: 30, y: 8, name: "Potion", taken: false }
  ],
  npcs: [
    {
      name: "Guard",
      x: 15, y: 8,
      color: "#ff0",
      path: [{ x: 15, y: 8 }, { x: 19, y: 8 }, { x: 19, y: 10 }, { x: 15, y: 10 }],
      pathIndex: 0,
      state: 0,
      dialogues: [
        "Guard(0): \"Halt, traveler! (E) to talk.\"",
        "Guard(1): \"(1) Name? Keep pressing E...\"",
        "Guard(2): \"(2) We watch roads...\"",
        "Guard(3): \"(3) Are you (G)ood or (E)vil?\"",
        "Guard(4): \"(4) Aha, interesting...\"",
        "Guard(5): \"(5) 5 lines done, 5 left...\"",
        "Guard(6): \"(6) I'm bored...\"",
        "Guard(7): \"(7) 3 more...\"",
        "Guard(8): \"(8) 2 more...\"",
        "Guard(9): \"(9) 1 more...\"",
        "Guard(10): \"(10) Done. Bye!\""
      ]
    },
    {
      name: "Wizard",
      x: 40, y: 5,
      color: "#f0f",
      path: [{ x: 40, y: 5 }, { x: 44, y: 5 }, { x: 44, y: 9 }, { x: 40, y: 9 }],
      pathIndex: 0,
      state: 0,
      dialogues: [
        "Wizard(0): \"Greetings. (E) to chat.\"",
        "Wizard(1): \"(1) I'm studying fire magic... (Y/N)?\"",
        "Wizard(2): \"(2) Great, I'll show you some spells!\"",
        "Wizard(3): \"(3) Fine, I'll keep them secret.\"",
        "Wizard(4): \"(4) I might hurl a fireball, watch out!\"",
        "Wizard(5): \"(5) If you see it, press (F) to block...\"",
        "Wizard(6): \"(6) I'm done talking soon...\"",
        "Wizard(7): \"(7) 3 lines left...\"",
        "Wizard(8): \"(8) 2 lines...\"",
        "Wizard(9): \"(9) 1 line...\"",
        "Wizard(10): \"(10) Enough!\""
      ]
    }
  ],
  projectiles: []
};

let map = Array.from({length: MAP_HEIGHT}, () => Array(MAP_WIDTH).fill("GRASS"));

let heightMap = Array.from({length: MAP_HEIGHT+1}, () => Array(MAP_WIDTH+1).fill(0));

function blurHeights(iterations=2){
  for(let i=0;i<iterations;i++){
    const next=heightMap.map(arr=>arr.slice());
    for(let y=0;y<=MAP_HEIGHT;y++){
      for(let x=0;x<=MAP_WIDTH;x++){
        let acc=0,count=0;
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const ny=y+dy,nx=x+dx;
            if(nx<0||ny<0||nx>MAP_WIDTH||ny>MAP_HEIGHT) continue;
            acc+=heightMap[ny][nx];
            count++;
          }
        }
        next[y][x]=acc/count;
      }
    }
    heightMap=next;
  }
}

function generateHeightMap(){
  heightMap = Array.from({length: MAP_HEIGHT+1}, () => Array(MAP_WIDTH+1).fill(0));
  const addHill=(cx,cy,amp,radius)=>{
    const minY=Math.max(0,Math.floor(cy-radius));
    const maxY=Math.min(MAP_HEIGHT,Math.ceil(cy+radius));
    const minX=Math.max(0,Math.floor(cx-radius));
    const maxX=Math.min(MAP_WIDTH,Math.ceil(cx+radius));
    for(let y=minY;y<=maxY;y++){
      for(let x=minX;x<=maxX;x++){
        const dx=x-cx,dy=y-cy;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist>radius) continue;
        const falloff=Math.pow(1-dist/radius,2);
        heightMap[y][x]+=amp*falloff;
      }
    }
  };

  const hillCount=70;
  for(let i=0;i<hillCount;i++){
    const cx=Math.random()*MAP_WIDTH;
    const cy=Math.random()*MAP_HEIGHT;
    const radius=8+Math.random()*14;
    const amp=-2+Math.random()*10; // some valleys, some peaks
    addHill(cx,cy,amp,radius);
  }

  blurHeights(3);

  // Emphasize relief so water, hills and peaks feel distinct
  for(let y=0;y<=MAP_HEIGHT;y++){
    for(let x=0;x<=MAP_WIDTH;x++){
      heightMap[y][x]=Math.round(heightMap[y][x]*1.2);
    }
  }

  blurHeights(1);
}

generateHeightMap();

for(let y=0;y<MAP_HEIGHT;y++){
  for(let x=0;x<MAP_WIDTH;x++){
    const avgH=(heightMap[y][x]+heightMap[y+1][x]+heightMap[y][x+1]+heightMap[y+1][x+1])/4;
    if(avgH<-1){
      map[y][x]="WATER";
    }else if(avgH<1){
      map[y][x]=Math.random()<0.65?"GRASS":"WATER";
    }else if(avgH<3){
      map[y][x]=Math.random()<0.35?"FOREST":"GRASS";
    }else if(avgH<6){
      map[y][x]=Math.random()<0.6?"HILL":"FOREST";
    }else{
      map[y][x]=Math.random()<0.35?"MOUNTAIN":"HILL";
    }
  }
}

function roadBrush(x,y,width){
  for(let dy=-width+1;dy<width;dy++){
    for(let dx=-width+1;dx<width;dx++){
      const rx=x+dx, ry=y+dy;
      if(rx>=0&&ry>=0&&rx<MAP_WIDTH&&ry<MAP_HEIGHT) map[ry][rx]="ROAD";
    }
  }
}

function carveRoad(x1,y1,x2,y2,width=1){
  let cx=x1, cy=y1;
  roadBrush(cx,cy,width);
  while(cx!==x2||cy!==y2){
    if(Math.abs(x2-cx)>Math.abs(y2-cy)) cx+= (x2>cx?1:-1); else cy+= (y2>cy?1:-1);
    roadBrush(cx,cy,width);
  }
}

function carvePolyline(points,width=1){
  for(let i=0;i<points.length-1;i++){
    carveRoad(points[i].x,points[i].y,points[i+1].x,points[i+1].y,width);
  }
}

function vertexTouchesRoad(vx,vy){
  const touchesTile=(tx,ty)=>tx>=0&&ty>=0&&tx<MAP_WIDTH&&ty<MAP_HEIGHT&&map[ty][tx]==="ROAD";
  return touchesTile(vx-1,vy-1)||touchesTile(vx,vy-1)||touchesTile(vx-1,vy)||touchesTile(vx,vy);
}

function smoothRoadHeights(iterations=3){
  for(let s=0;s<iterations;s++){
    const next=heightMap.map(r=>r.slice());
    for(let y=0;y<=MAP_HEIGHT;y++){
      for(let x=0;x<=MAP_WIDTH;x++){
        if(!vertexTouchesRoad(x,y)) continue;
        let acc=0,count=0;
        for(let dy=-1;dy<=1;dy++){
          for(let dx=-1;dx<=1;dx++){
            const nx=x+dx,ny=y+dy;
            if(nx<0||ny<0||nx>MAP_WIDTH||ny>MAP_HEIGHT) continue;
            if(!vertexTouchesRoad(nx,ny)) continue;
            acc+=heightMap[ny][nx];
            count++;
          }
        }
        if(count>0) next[y][x]=Math.round(acc/count);
      }
    }
    heightMap=next;
  }
}

function placeRect(x,y,w,h,type){
  for(let yy=y;yy<y+h;yy++){
    if(yy<0||yy>=MAP_HEIGHT) continue;
    for(let xx=x;xx<x+w;xx++){
      if(xx<0||xx>=MAP_WIDTH) continue;
      map[yy][xx]=type;
    }
  }
}

// Major road network: three clear arterial routes
const midY=Math.floor(MAP_HEIGHT/2);
const midX=Math.floor(MAP_WIDTH/2);
const royalRoad=[{x:0,y:midY-2},{x:midX-4,y:midY-2},{x:MAP_WIDTH-1,y:midY}];
const merchantSpine=[{x:midX,y:0},{x:midX+2,y:midY},{x:midX,y:MAP_HEIGHT-1}];
const ridgePass=[{x:2,y:8},{x:midX-6,y:midY-6},{x:MAP_WIDTH-6,y:MAP_HEIGHT-10}];
carvePolyline(royalRoad,2);
carvePolyline(merchantSpine,2);
carvePolyline(ridgePass,1);

// Short connectors to bring settlements onto the mains
const roadNodes=[
  {x:10,y:10}, // spawn
  {x:32,y:20}, // castle
  {x:22,y:26}, // village cluster
  {x:52,y:8},  // tower
  {x:72,y:12}, // walled city
  {x:92,y:24}, // village east
  {x:114,y:36} // eastern city
];
carvePolyline([{x:10,y:10},{x:22,y:26},{x:32,y:20}],2);
carvePolyline([{x:52,y:8},{x:72,y:12},{x:92,y:24}],1);
carvePolyline([{x:92,y:24},{x:114,y:36}],2);

smoothRoadHeights();

// City with walls
for(let yy=10;yy<16;yy++){for(let xx=70;xx<76;xx++){map[yy][xx]="CITY";}}
for(let xx=69;xx<=76;xx++){map[10][xx]="WALL";map[15][xx]="WALL";}
for(let yy=10;yy<=15;yy++){map[yy][69]="WALL";map[yy][76]="WALL";}

// Castle keep and settlements
placeRect(32,18,4,4,"CASTLE");
placeRect(18,28,6,4,"VILLAGE");
placeRect(22,24,4,3,"FARM");
placeRect(50,6,3,3,"TOWER");
placeRect(90,26,5,4,"VILLAGE");
placeRect(94,22,4,3,"FARM");
placeRect(112,34,6,4,"CITY");
placeRect(58,14,3,3,"BUILDING");
placeRect(84,18,4,3,"BUILDING");
placeRect(104,30,5,3,"BUILDING");
placeRect(14,14,3,3,"BUILDING");
placeRect(44,26,4,3,"BUILDING");
placeRect(64,32,4,3,"BUILDING");
placeRect(76,6,3,3,"BUILDING");

let isRunning=true;
let score=0;
let playerX=10,playerY=10;
let playerFacing='S';
let walkFrame=0,moveDelay=333,lastMove=0;
let playerStats={name:"BezImienny",ZYW:100,currentHP:100,SF:60,ZR:50,UM:30,WI:40,SZ:20,PM:20,inventory:[]};
let rageActive=false,rageTimer=0;
let dayTime=0;function currentDayPhase(){if(dayTime<1200) return"Day";else if(dayTime<1800) return"Evening";else return"Night";}

let keys={ArrowUp:false,ArrowDown:false,ArrowLeft:false,ArrowRight:false,t:false,T:false,e:false,E:false,i:false,I:false,f:false,F:false,s:false,S:false,g:false,G:false,y:false,Y:false,n:false,N:false};
window.addEventListener("keydown",e=>{if(keys[e.key]!==undefined) keys[e.key]=true;});
window.addEventListener("keyup",e=>{if(keys[e.key]!==undefined) keys[e.key]=false;});

const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
const messagesDiv=document.getElementById('messages');
const dialoguesDiv=document.getElementById('dialogues');
const statsDiv=document.getElementById('playerStats');

function resizeCanvas(){
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function isNPCat(nx,ny){return gameData.npcs.find(n=>n.x===nx&&n.y===ny);}
function isPassable(nx,ny){if(nx<0||ny<0||nx>=MAP_WIDTH||ny>=MAP_HEIGHT) return false;let npc=isNPCat(nx,ny);if(npc) return false;let td=gameData.tileDefs[map[ny][nx]]||gameData.tileDefs.GRASS;return td.passable!==false;}
function isRoad(nx,ny){return nx>=0&&ny>=0&&nx<MAP_WIDTH&&ny<MAP_HEIGHT&&map[ny][nx]==="ROAD";}
function isAdjacent(px,py,nx,ny){return Math.abs(px-nx)+Math.abs(py-ny)===1;}

let npcMoveInterval=1000,lastNPCmove=0;
function updateNPCs(){let now=Date.now();if(now-lastNPCmove<npcMoveInterval) return;lastNPCmove=now;for(let npc of gameData.npcs){if(!npc.path||npc.path.length<2) continue;if(npc.pathIndex===undefined) npc.pathIndex=0;let tgt=npc.path[npc.pathIndex];if(npc.x===tgt.x&&npc.y===tgt.y){npc.pathIndex=(npc.pathIndex+1)%npc.path.length;tgt=npc.path[npc.pathIndex];}let dx=0,dy=0;if(npc.x<tgt.x) dx=1;else if(npc.x>tgt.x) dx=-1;else if(npc.y<tgt.y) dy=1;else if(npc.y>tgt.y) dy=-1;let nx=npc.x+dx,ny=npc.y+dy;if(isPassable(nx,ny)){npc.x=nx;npc.y=ny;}}
let wizard=gameData.npcs.find(n=>n.name==="Wizard");if(wizard&&Math.random()<0.33){let dx=playerX-wizard.x,dy=playerY-wizard.y;if(Math.abs(dx)>Math.abs(dy)){gameData.projectiles.push({x:wizard.x,y:wizard.y,dx:(dx>0?1:-1),dy:0,type:"FIREBALL"});messagesDiv.textContent="Wizard hurls a fireball horizontally!";}else{gameData.projectiles.push({x:wizard.x,y:wizard.y,dx:0,dy:(dy>0?1:-1),type:"FIREBALL"});messagesDiv.textContent="Wizard flings a vertical fireball!";}}}

function updateProjectiles(){let removeList=[];for(let p of gameData.projectiles){p.x+=p.dx;p.y+=p.dy;if(p.x<0||p.y<0||p.x>=MAP_WIDTH||p.y>=MAP_HEIGHT){removeList.push(p);continue;}if(p.x===playerX&&p.y===playerY){if(keys.f||keys.F){messagesDiv.textContent="You block the fireball with perfect timing!";}else{playerStats.currentHP-=10;messagesDiv.textContent="Fireball hits you for 10 damage!";if(playerStats.currentHP<=0){playerStats.currentHP=0;messagesDiv.textContent+=" You died! Game Over.";isRunning=false;}}removeList.push(p);}else if(!isPassable(p.x,p.y)){removeList.push(p);}}
gameData.projectiles=gameData.projectiles.filter(x=>!removeList.includes(x));}

let lastDayUpdate=0;messagesDiv.textContent="Map generated. Use arrow keys to move. 'S' for Szał. 'F' to block fireballs.";

let cameraXFloat=0,cameraYFloat=0;
function isoPoint(rx,ry,h=0){
  return {sx:(rx-ry)*TILE_W/2, sy:(rx+ry)*TILE_H/2 - h*TILE_Z};
}

function shadeColor(col,amt){
  if(col.length===4) col="#"+col[1]+col[1]+col[2]+col[2]+col[3]+col[3];
  let num=parseInt(col.slice(1),16);
  let r=(num>>16)+amt,g=((num>>8)&0xFF)+amt,b=(num&0xFF)+amt;
  r=Math.min(255,Math.max(0,r));
  g=Math.min(255,Math.max(0,g));
  b=Math.min(255,Math.max(0,b));
  return"#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
}

const dirVectors={
  N:{sx:TILE_W/2,sy:-TILE_H/2},
  S:{sx:-TILE_W/2,sy:TILE_H/2},
  E:{sx:TILE_W/2,sy:TILE_H/2},
  W:{sx:-TILE_W/2,sy:-TILE_H/2}
};
function dirVector(facing){return dirVectors[facing]||dirVectors.S;}

function fillPoly(points,color){
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.moveTo(points[0].sx,points[0].sy);
  for(let i=1;i<points.length;i++) ctx.lineTo(points[i].sx,points[i].sy);
  ctx.closePath();
  ctx.fill();
}

function drawPlayerArrow(center,facing){
  const forward=dirVector(facing);
  const norm=Math.sqrt(forward.sx*forward.sx+forward.sy*forward.sy)||1;
  const fUnit={sx:forward.sx/norm,sy:forward.sy/norm};
  const length=24;
  const baseOffset=-8;
  const halfWidth=9;
  const height=14+Math.sin(Date.now()/180)*2;
  const base={sx:center.sx+fUnit.sx*baseOffset,sy:center.sy+4+fUnit.sy*baseOffset};
  const tip={sx:base.sx+fUnit.sx*length,sy:base.sy+fUnit.sy*length};
  const perp={sx:-fUnit.sy*halfWidth,sy:fUnit.sx*halfWidth};
  const left={sx:base.sx+perp.sx,sy:base.sy+perp.sy};
  const right={sx:base.sx-perp.sx,sy:base.sy-perp.sy};
  const topShift={sx:0,sy:-height};
  const tTip={sx:tip.sx+topShift.sx,sy:tip.sy+topShift.sy};
  const tLeft={sx:left.sx+topShift.sx,sy:left.sy+topShift.sy};
  const tRight={sx:right.sx+topShift.sx,sy:right.sy+topShift.sy};
  const body=shadeColor(gameData.specialTiles.PLAYER,-5);
  const shadow=shadeColor(body,-35);
  const highlight=shadeColor(body,30);
  fillPoly([left,right,tRight,tLeft],shadow);
  fillPoly([tip,right,tRight,tTip],shadeColor(body,-15));
  fillPoly([tip,left,tLeft,tTip],shadeColor(body,-5));
  fillPoly([tTip,tRight,tLeft],highlight);
}

function gameLoop(){if(!isRunning) return;let now=Date.now();if(now-lastDayUpdate>1000){dayTime=(dayTime+20)%2400;lastDayUpdate=now;}updateNPCs();updateProjectiles();if(now-lastMove>=moveDelay){let moved=false;const moveOptions=[{key:'ArrowUp',dx:0,dy:-1,facing:'N'},{key:'ArrowDown',dx:0,dy:1,facing:'S'},{key:'ArrowLeft',dx:-1,dy:0,facing:'W'},{key:'ArrowRight',dx:1,dy:0,facing:'E'}];for(const opt of moveOptions){if(keys[opt.key]){playerFacing=opt.facing;const nx=playerX+opt.dx,ny=playerY+opt.dy;if(isPassable(nx,ny)){playerX=nx;playerY=ny;moved=true;}break;}}if(moved){score++;walkFrame=(walkFrame+1)%2;lastMove=now;}else{walkFrame=0;}}else{walkFrame=0;}
let it=gameData.items.find(i=>!i.taken&&i.x===playerX&&i.y===playerY);if(it){messagesDiv.textContent=`You see a ${it.name}. Press (T) to take.`;if(keys.t||keys.T){it.taken=true;playerStats.inventory.push(it.name);messagesDiv.textContent=`You took ${it.name}!`;}}
if(keys.i||keys.I){messagesDiv.textContent=`Inventory: [${playerStats.inventory.join(", ")}]`;}
let npc=gameData.npcs.find(n=>isAdjacent(playerX,playerY,n.x,n.y));if(npc){let st=npc.state;if(st>=npc.dialogues.length) st=npc.dialogues.length-1;dialoguesDiv.textContent=npc.dialogues[st];if(keys.e||keys.E){let line=npc.dialogues[npc.state];if(line.includes("(G)ood or (E)vil?")){if(keys.g||keys.G) npc.state+=2;else if(keys.e||keys.E) npc.state+=3;else npc.state++;}else if(line.includes("(Y/N)")){if(keys.y||keys.Y) npc.state+=2;else if(keys.n||keys.N) npc.state+=3;else npc.state++;}else{npc.state++;}if(npc.state>=npc.dialogues.length){npc.state=npc.dialogues.length-1;}}}
if(keys.s||keys.S){if(!rageActive){rageActive=true;rageTimer=now+5000;playerStats.SF+=20;messagesDiv.textContent="Szał Bitewny! (+20 SF for 5s)";}keys.s=false;keys.S=false;}
if(rageActive&&now>rageTimer){rageActive=false;playerStats.SF-=20;messagesDiv.textContent+="\nSzał Bitewny ends, SF back to normal.";}
for(let k in keys){if(k!=='ArrowUp'&&k!=='ArrowDown'&&k!=='ArrowLeft'&&k!=='ArrowRight'&&keys[k]) keys[k]=false;}
statsDiv.textContent=`ZYW:${playerStats.currentHP}/${playerStats.ZYW} | SF:${playerStats.SF} | ZR:${playerStats.ZR} | UM:${playerStats.UM} | WI:${playerStats.WI} | SZ:${playerStats.SZ} | PM:${playerStats.PM} | Time:${currentDayPhase()} | Score:${score}`;
let targetCamX=playerX-CAMERA_WIDTH/2;let targetCamY=playerY-CAMERA_HEIGHT/2;if(targetCamX<0) targetCamX=0;if(targetCamY<0) targetCamY=0;if(targetCamX+CAMERA_WIDTH>MAP_WIDTH) targetCamX=MAP_WIDTH-CAMERA_WIDTH;if(targetCamY+CAMERA_HEIGHT>MAP_HEIGHT) targetCamY=MAP_HEIGHT-CAMERA_HEIGHT;let speed=0.12;cameraXFloat+= (targetCamX-cameraXFloat)*speed;cameraYFloat+=(targetCamY-cameraYFloat)*speed;
render();requestAnimationFrame(gameLoop);}

function drawTile(p1,p2,p3,p4,color){
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.moveTo(p1.sx,p1.sy);
  ctx.lineTo(p2.sx,p2.sy);
  ctx.lineTo(p3.sx,p3.sy);
  ctx.lineTo(p4.sx,p4.sy);
  ctx.closePath();
  ctx.fill();
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const centerX=canvas.width/2;
  const centerY=90;
  for(let row=0;row<=CAMERA_HEIGHT;row++){
    for(let col=0;col<=CAMERA_WIDTH;col++){
      const wx=Math.floor(cameraXFloat+col);
      const wy=Math.floor(cameraYFloat+row);
      if(wx<0||wy<0||wx>=MAP_WIDTH||wy>=MAP_HEIGHT) continue;
      const rx=wx-cameraXFloat;
      const ry=wy-cameraYFloat;
      const hNW=heightMap[wy][wx];
      const hNE=heightMap[wy][wx+1];
      const hSW=heightMap[wy+1][wx];
      const hSE=heightMap[wy+1][wx+1];
      const baseHeight=Math.min(hNW,hNE,hSW,hSE,0);

      const pNW=isoPoint(rx,ry,hNW);
      const pNE=isoPoint(rx+1,ry,hNE);
      const pSE=isoPoint(rx+1,ry+1,hSE);
      const pSW=isoPoint(rx,ry+1,hSW);
      const bNW=isoPoint(rx,ry,baseHeight);
      const bNE=isoPoint(rx+1,ry,baseHeight);
      const bSE=isoPoint(rx+1,ry+1,baseHeight);
      const bSW=isoPoint(rx,ry+1,baseHeight);

      for (const pt of [pNW,pNE,pSE,pSW,bNW,bNE,bSE,bSW]) {
        pt.sx+=centerX;
        pt.sy+=centerY;
      }
        const tileName=map[wy][wx];
        const td=gameData.tileDefs[tileName]||gameData.tileDefs.GRASS;
        const avgH=(hNW+hNE+hSW+hSE)/4;
        const topColor=shadeColor(td.color,-avgH*10);
        const leftColor=shadeColor(topColor,-25);
        const rightColor=shadeColor(topColor,-15);
        const frontColor=shadeColor(topColor,-35);
        const center=isoPoint(rx+0.5,ry+0.5,avgH);
        center.sx+=centerX;center.sy+=centerY;

        if(Math.max(hNW,hSW)>baseHeight){
          drawTile(pNW,pSW,bSW,bNW,leftColor);
        }
        if(Math.max(hNE,hSE)>baseHeight){
          drawTile(pNE,pSE,bSE,bNE,rightColor);
        }
        if(Math.max(hSW,hSE)>baseHeight){
          drawTile(pSW,pSE,bSE,bSW,frontColor);
        }

        drawTile(pNW,pNE,pSE,pSW,topColor);

        if (tileName==="ROAD") {
          const centerPoint = { sx: center.sx, sy: center.sy + 4 };
          const edges={
            N:{pt:{sx:(pNW.sx+pNE.sx)/2,sy:(pNW.sy+pNE.sy)/2}},
            S:{pt:{sx:(pSW.sx+pSE.sx)/2,sy:(pSW.sy+pSE.sy)/2}},
            W:{pt:{sx:(pNW.sx+pSW.sx)/2,sy:(pNW.sy+pSW.sy)/2}},
            E:{pt:{sx:(pNE.sx+pSE.sx)/2,sy:(pNE.sy+pSE.sy)/2}}
          };
          const neighbors={
            N:isRoad(wx,wy-1),
            S:isRoad(wx,wy+1),
            W:isRoad(wx-1,wy),
            E:isRoad(wx+1,wy)
          };

          const dirOrder=["N","E","S","W"];
          const strokeRoad=(width,color,dash=[])=>{
            ctx.lineCap="round";
            ctx.lineJoin="round";
            ctx.setLineDash(dash);
            ctx.strokeStyle=color;
            ctx.lineWidth=width;
            ctx.beginPath();
            ctx.moveTo(centerPoint.sx,centerPoint.sy);
            let drew=false;
            for(const dir of dirOrder){
              if(neighbors[dir]){
                ctx.lineTo(edges[dir].pt.sx,edges[dir].pt.sy);
                ctx.moveTo(centerPoint.sx,centerPoint.sy);
                drew=true;
              }
            }
            if(!drew){ctx.lineTo(centerPoint.sx,centerPoint.sy+0.1);} // isolated paving
            ctx.stroke();
            ctx.setLineDash([]);
          };

          strokeRoad(14,shadeColor("#c2ad88",-avgH));
          strokeRoad(10,shadeColor("#e8dfcd",-avgH));
          strokeRoad(2,shadeColor("#fff3bf",-avgH),[6,6]);
          ctx.lineWidth=1;
        }

        const buildingStyles={
          CASTLE:{color:"#d6d6d6",height:18,inset:0.58},
          CITY:{color:"#cfd5e8",height:16,inset:0.6},
          VILLAGE:{color:"#d9b07b",height:12,inset:0.64},
          TOWER:{color:"#c6c0ea",height:22,inset:0.64},
          FARM:{color:"#c9a871",height:10,inset:0.68},
          BUILDING:{color:"#b8c0d4",height:14,inset:0.62}
        };
        if(buildingStyles[tileName]){
          const {color,height,inset}=buildingStyles[tileName];
          const baseCenter={sx:center.sx,sy:center.sy+4};
          const insetPt=(pt)=>({
            sx:baseCenter.sx+(pt.sx-baseCenter.sx)*inset,
            sy:baseCenter.sy+(pt.sy-baseCenter.sy)*inset
          });
          const bNW=insetPt(pNW),bNE=insetPt(pNE),bSE=insetPt(pSE),bSW=insetPt(pSW);
          const tNW={sx:bNW.sx,sy:bNW.sy-height};
          const tNE={sx:bNE.sx,sy:bNE.sy-height};
          const tSE={sx:bSE.sx,sy:bSE.sy-height};
          const tSW={sx:bSW.sx,sy:bSW.sy-height};
          const wallShadow=shadeColor(color,-35);
          const wallMid=shadeColor(color,-20);
          const roof=shadeColor(color,20);
          drawTile(bNW,bSW,tSW,tNW,wallShadow);
          drawTile(bNE,bSE,tSE,tNE,wallMid);
          drawTile(bSW,bSE,tSE,tSW,shadeColor(color,-45));
          drawTile(tNW,tNE,tSE,tSW,roof);
        }

        const proj=gameData.projectiles.find(p=>p.x===wx&&p.y===wy);
      if(proj){ctx.fillStyle=gameData.specialTiles.FIREBALL.color;ctx.beginPath();ctx.arc(center.sx,center.sy+4,4,0,Math.PI*2);ctx.fill();}
      const it=gameData.items.find(i=>!i.taken&&i.x===wx&&i.y===wy);
      if(it){ctx.fillStyle=gameData.specialTiles.ITEM.color;ctx.beginPath();ctx.moveTo(center.sx,center.sy+2);ctx.lineTo(center.sx+4,center.sy+TILE_H/2);ctx.lineTo(center.sx,center.sy+TILE_H-2);ctx.lineTo(center.sx-4,center.sy+TILE_H/2);ctx.closePath();ctx.fill();}
      const npc=gameData.npcs.find(n=>n.x===wx&&n.y===wy);
      if(npc){ctx.fillStyle=npc.color||gameData.specialTiles.NPC.color;ctx.beginPath();ctx.arc(center.sx,center.sy+4,6,0,Math.PI*2);ctx.fill();}
      if(wx===playerX&&wy===playerY){drawPlayerArrow(center,playerFacing);}
      if(wx===playerX&&wy===playerY){
        ctx.strokeStyle="#ffeb3b";
        ctx.lineWidth=2;
        ctx.beginPath();
        ctx.moveTo(pNW.sx,pNW.sy);
        ctx.lineTo(pNE.sx,pNE.sy);
        ctx.lineTo(pSE.sx,pSE.sy);
        ctx.lineTo(pSW.sx,pSW.sy);
        ctx.closePath();
        ctx.stroke();
        ctx.lineWidth=1;
      }
    }
  }
}
requestAnimationFrame(gameLoop);
</script>
</body>
<!-- RPG v 0.2.1 -->
</html>
